{"fileName":"1. 响应式和数据通讯.md","dirList":["docs","微信相关","小程序"],"name":"1. 响应式和数据通讯","createTime":1684334971515.1697,"modifyTime":1684341111184.2366,"data":"\n# 小程序响应式\n\n在微信小程序中，响应式数据通常使用数据绑定和数据监听的方式实现。\n\n1. 数据绑定\n\n> 可以使用双大括号{{}}将数据绑定到小程序的视图层（WXML）中。例如，将一个变量message绑定到文本节点：\n\n```html\n<view>{{message}}</view>\n<button bindtap=\"updateMessage\">点我更新</button>\n\n```\n\n- 触发更新和监听数据\n\n```js\nPage({\n  data: {\n    message: 'Hello World'\n  },\n  updateMessage: function () {\n    this.setData({\n      message: 'New Message'\n    });\n  },\n  // 监听数据\n  watch: {\n    'message': function (newVal, oldVal) {\n      console.log('message changed:', newVal, oldVal);\n    }\n  }\n})\n```\n\n# 数据通讯\n\n## 父组件与子组件通讯 properties\n\n可通过`properties`来进行通讯。类似于vue的`props`\n\n```js\n// count.wxml\n<text>{{count}}</text>\n\n// count.ts\nComponent({\n  properties: {\n    count: {\n      type: Number,\n      value: 0,\n    }\n  },\n});\n\n// index.ts\nPage({\n  data: {\n    count: 0\n  },\n\n  add: function() {\n    this.setData({\n      count: this.data.count + 1,\n    });\n  },\n});\n\n// index.wxml\n<t-button bindtap=\"add\">点我</t-button><text>{{count}}</text>\n<view>child count: <count count=\"{{count}}\"></count></view>\n```\n\n可以看出在按钮被点击的时候，父子组件的count同时变化\n\n### properties中的observer\n\n`properties`中的`observer`方法会在属性变化的时候执行，可以更新子组件内部的状态。\n\n```js\n// count.wxml\n<view>count: {{count}}, sum: {{sum}}</view>\n\n// count.ts\n// 计算 1+2+...+count 的结果\nconst compute = (count: number) => {\n  return (1 + count) * count / 2;\n}\n\nComponent({\n  properties: {\n    count: {\n      type: Number,\n      value: 0,\n      observer(newVal: number) {\n        // 属性变化时执行操作\n        this.setData({\n          sum: compute(newVal), // 更新子组件内部的状态\n        });\n      }\n    }\n  },\n  data: {\n    sum: 0\n  },\n})\n```\n\n## 子组件与父组件通讯 triggerEvent\n\n子组件可以通过触发事件来通知父组件发生了某个动作或传递数据，在子组件中使用this.triggerEvent方法触发自定义事件。类似于Vue的`emits`\n\n```js\n// child.js\nComponent({\n  methods: {\n    handleClick() {\n      const data = 'Hello, parent component!';\n      this.triggerEvent('customEvent', { data });\n    }\n  }\n});\n\n// father.wxml\n<child-component bind:customEvent=\"handleEvent\" />\n\n// father.js\nPage({\n  handleEvent(event) {\n    const { data } = event.detail;\n    console.log(data); // 输出：Hello, parent component!\n  }\n});\n```\n\n## 全局数据对象和监听\n\n在微信小程序中，可以通过使用全局数据的监听器来监听全局数据的修改。`感觉是简单的状态管理工具`\n\n```js\n// 1. 创建全局数据对象：在小程序的入口文件中，定义一个全局数据对象。\n\n// app.js\nApp({\n  globalData: {\n    userInfo: null // 全局数据\n  }\n})\n\n// 2. 添加监听器：在需要监听全局数据修改的页面或组件中。\n// pageXxx.js\nPage({\n  onLoad() {\n    const app = getApp();\n    this.watch = app.globalData.watch; // 获取全局数据的监听器\n\n    // 添加监听器\n    this.watch(this.handleUserInfoChange, 'userInfo');\n  },\n  handleUserInfoChange(newVal, oldVal) {\n    // 全局数据修改时触发的回调函数\n    console.log('userInfo changed:', newVal, oldVal);\n  },\n  onUnload() {\n    // 页面或组件销毁时，移除监听器\n    this.watch(null, 'userInfo');\n  }\n}) \n```\n\n在上述代码中，通过`getApp()`方法获取小程序实例，并使用`globalData.watch`来获取全局数据的监听器函数。然后，在`onLoad`生命周期函数中添加监听器，指定要监听的全局数据字段名（如`userInfo`）。当全局数据的指定字段发生修改时，触发指定的回调函数`handleUserInfoChange`。\n\n### 全局数据对象的使用注意事项\n\n- 销毁监听器\n\n在页面或组件销毁时，需要通过调用监听器函数并传入null，并指定要移除的全局数据字段名，以避免内存泄漏。\n\n- 谨慎使用局部数据对象\n\n直接在页面或组件中定义和修改`globalData`并不是推荐的做法。因为在小程序中，页面和组件的创建和销毁是动态的，可能会频繁地加载和卸载，而且页面和组件之间的生命周期可能不同，直接在其中定义和修改`globalData`会导致数据的管理和维护变得困难。\n\n# End\n\n感谢看到这里，给你大拇哥！"}