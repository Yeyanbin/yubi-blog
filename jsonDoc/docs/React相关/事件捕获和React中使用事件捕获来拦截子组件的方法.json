{"fileName":"事件捕获和React中使用事件捕获来拦截子组件的方法.md","dirList":["docs","React相关"],"name":"事件捕获和React中使用事件捕获来拦截子组件的方法","createTime":1679414070447.4219,"modifyTime":1679414071896.9634,"data":"# 事件捕获\n\n本文会介绍事件捕获，给出原生DEMO，React实现DEMO，再编写出拦截子组件的点击行为的React组件。\n\n## 原生Javascript中的事件捕获\n\nJavaScript的事件捕获是一种处理DOM事件的机制，它处理事件的过程是从文档树的根部向下传递直到达到触发事件的目标元素。与之相对的是事件冒泡，它处理事件的过程是从目标元素开始向上传递到文档树的根部。\n\n> 在实践中，可以使用addEventListener方法来注册事件捕获处理程序。该方法接受三个参数：要监听的事件类型、事件处理函数以及一个布尔值，表示事件是否应该在捕获阶段处理。如果该值为true，则在捕获阶段处理事件；如果该值为false（默认情况），则在事件冒泡阶段处理事件。\n\n例如，以下代码演示了如何使用事件捕获来处理点击事件：\n\n```html\n<div id=\"outer\">\n  <div id=\"inner\">\n    Click me!\n  </div>\n</div>\n```\n\n```javascript\nconst outer = document.getElementById('outer');\nconst inner = document.getElementById('inner');\n\nouter.addEventListener('click', function() {\n  console.log('Capturing: outer');\n}, true);\n\ninner.addEventListener('click', function() {\n  console.log('Capturing: inner');\n}, true);\n\nouter.addEventListener('click', function() {\n  console.log('Bubbling: outer');\n});\n\ninner.addEventListener('click', function() {\n  console.log('Bubbling: inner');\n});\n```\n\n当用户单击“点击我”文本时，事件处理程序将按照以下顺序运行：\n\n1. 捕获阶段：处理外部元素上的事件侦听器（打印“Capturing: outer”）。\n2. 捕获阶段：处理内部元素上的事件侦听器（打印“Capturing: inner”）。\n3. 冒泡阶段：处理内部元素上的事件侦听器（打印“Bubbling: inner”）。\n4. 冒泡阶段：处理外部元素上的事件侦听器（打印“Bubbling: outer”）。\n\n## React实现事件捕获DEMO\n\n在React函数式组件中实现事件捕获，可以使用useCapture参数来设置事件监听的模式。具体实现方法如下：\n\n```jsx\nimport React, { useRef } from 'react';\n\nfunction MyComponent() {\n  const outerRef = useRef(null);\n  const innerRef = useRef(null);\n\n  const handleClick = (event) => {\n    console.log(`Event target: ${event.currentTarget.id}`);\n  };\n\n  return (\n    <div id=\"outer\" ref={outerRef} onClickCapture={handleClick}>\n      <div id=\"inner\" ref={innerRef} onClickCapture={handleClick}>\n        Click me!\n      </div>\n    </div>\n  );\n}\n```\n\n在这个示例中，我们使用了React的useRef钩子来获取DOM节点的引用，并通过onClickCapture属性将事件处理程序添加到外部和内部元素。当用户单击“Click me!”文本时，事件处理程序将按照以下顺序运行：\n\n1. 捕获阶段：处理外部元素上的事件侦听器（打印“Event target: outer”）。\n2. 捕获阶段：处理内部元素上的事件侦听器（打印“Event target: inner”）。\n\n>注意，我们在onClickCapture属性中使用了驼峰命名法而不是传统的小写事件名称。这是因为React中的事件处理程序采用了一种合成事件的机制，它与原生DOM事件略有不同。此外，如果需要在事件冒泡阶段处理事件，则可以使用onClick属性（或其他支持的事件名称），而无需显式地指定useCapture参数。\n\n事件停止传播其实很简单，我们只需要在React DOM的挂载方法中，执行`stopPropagation`来停止传播就行了。\n\n```jsx\n// 让我们加一下\nconst handleClick = (event) => {\n  console.log(`Event target: ${event.currentTarget.id}`);\n  event.stopPropagation();\n};\n```\n\n现在就只会打印“Event target: outer”。\n\n\n## 设计拦截子组件的点击行为的React组件\n\n// 未完待续"}