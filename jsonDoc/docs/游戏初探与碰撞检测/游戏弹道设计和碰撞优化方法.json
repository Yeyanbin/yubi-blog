{"fileName":"游戏弹道设计和碰撞优化方法.md","dirList":["docs","游戏初探与碰撞检测"],"name":"游戏弹道设计和碰撞优化方法","createTime":1679414070459.959,"modifyTime":1679414071350.1816,"data":"\n# evajs简单介绍\n\nEva.js 是一个专注于开发互动游戏项目的前端游戏引擎。选用这个库的原因主要是开箱即用。\n\n是淘宝团队的一款开源库，天猫农场，金币庄园，\n\n> demo的Url https://yeyanbin.github.io/mac-dialog-demo/dist/\n\n## 资源管理\n\n游戏中所用到的所有资源都会放在资源管理器中进行管理，在使用资源之前需要将资源添加到资源管理器中，并为资源设置一个资源名，在需要时直接使用资源名。\n\n```js\n// 引入一个资源\nresource.addResource([\n  {\n    name: 'bear',\n    type: RESOURCE_TYPE.IMAGE,\n    src: {\n      image: {\n        type: 'png',\n        url: getUrlPrefix() + '/bunny.png'\n      },\n    },\n    preload: true,\n  },\n]);\n```\n\n## 游戏 Game\n\n通过 Game 实例上的方法，控制游戏暂停、继续。通过将 System 添加到 Game 上让游戏能够支持不同的能力，这些能力都是通过组件添加到 GameObject 上展现出来的。\n\n### 添加系统​\n\n我们可以在创建的时候添加系统\n\n```js\n// 创建一个游戏\nconst canvas = document.querySelector('#game-canvas');\n\nconst game = new Game({\n  systems: [\n    // 渲染系统\n    new RendererSystem({\n      canvas,\n      width: 1000,\n      height: 1000,\n      backgroundColor: 0x999999\n    }),\n    // 图片系统\n    new ImgSystem(),\n  ],\n});\n```\n\n## 游戏对象 GameObject\n\n游戏对象是游戏的基本元素，代表人物、物体、风景等。\n\n## 创建一个角色\n\n```js\n// 创建游戏对象，bear\nconst bear = new GameObject('bear', {\n  size: { width: 30, height: 40 },\n  origin: { x: 0.5, y: 0.5 },\n  position: {\n    x: 500,\n    y: 500,\n  },\n  anchor: {\n    x: 0,\n    y: 0,\n  },\n});\n\n// 添加子组件，为小熊的图片\nbear.addComponent(\n  new Img({\n    resource: 'bearImg',\n  })\n);\n\n// 把该游戏对象加入到游戏里。\ngame.scene.addChild(bear);\n```\n\n## Ticker\n\n增加每帧执行的方法\n\n```js\ngame.ticker.add((e: UpdateParams)=>{\n  // 这个部分的代码会每帧都执行一遍\n});\n```\n\n## 控制角色的移动\n\n### 一，跟随鼠标移动\n\n这里我们用挂载原生的事件来实现。**参考跟随鼠标Demo**\n\n```js\ncanvas.addEventListener('mousemove', (ev) => {\n  bear.transform.position = {\n    x: ev.offsetX,\n    y: ev.offsetY,\n  };\n  ev.stopPropagation()\n});\n```\n\n### 二，用键盘控制移动\n\n这里需要引入一个数学上的概念，反正切函数 $ y =arctan（x）$，我们需要用到他来获取移动的方向。**参考点击移动Demo，键盘移动Demo和双人移动Demo**\n\n```js\n// 获取角度\nconst rotateToPoint = (mx, my, px, py) => {\n  const dist_Y = my - py;\n  const dist_X = mx - px;\n  const angle = Math.atan2(dist_Y, dist_X);\n  return angle;\n}\n\n// 记录移动方向的角度\nconst rotatesMap = {\n  \"right\": 0,\n  \"up\": -Math.PI/2,\n  \"left\": Math.PI,\n  \"down\": Math.PI/2,\n  \"right+up\": -Math.PI/4,\n  \"left+up\": -Math.PI*3/4,\n  \"right+down\": Math.PI/4,\n  \"left+down\": Math.PI*3/4\n}\n```\n\n我们获取到移动的方向之后，就可以绑定对应的移动按键，然后在Ticker中改变GameObject来实现移动动画。\n\n```js\n// Ticker\ngame.ticker.add((e: UpdateParams)=>{\n  // 是否允许移动\n  if (move.isMove) {\n    // 计算移动距离\n    const moveDis = move.moveSpeed * (Date.now() - move.lastMoveTime)/1000;\n    \n    // 计算下一个坐标\n    const position = gameObj.transform.position;\n    position.x += Math.cos(move.moveRotation) * moveDis;\n    position.y += Math.sin(move.moveRotation) * moveDis;\n    move.lastMoveTime = Date.now();\n  }\n});\n```\n\n### 子弹与碰撞\n\n#### 射击行为\n\n到了这里我们就可以实现游戏对象GameObject的移动了，而角色和子弹都是游戏对象，所以我们可以用上述方法去实现子弹的移动。**参考点击射击Demo，自动射击Demo和随机射击Demo**\n\n```js\n// 1. 定义子弹的属性，速度\nconst bulletSpeed = 50;\nconst bullets: GameObject[] = [];\nlet lastMoveTime = Date.now();\n\n// 2. 绑定点击事件，获取射击角度和开始位置\ncanvas.addEventListener('mousedown', (ev) => {\n  ev.stopPropagation()\n  const { offsetX, offsetY } = ev; \n  shoot(rotateToPoint(offsetX, offsetY, bear.transform.position.x, bear.transform.position.y), bear.transform.position);\n});\n\n// 3. 创建子弹的游戏对象，绑定子弹的图片资源，加入到子弹集合\nfunction shoot(rotation, startPosition) {\n\n  const bulletsGameObj = new GameObject('gameObject1', {\n    size: { width: 25, height: 12 },\n    origin: { x: 0.5, y: 0.5 },\n    position: startPosition,\n    rotation\n  })\n  bulletsGameObj.addComponent(\n    new Img({\n      resource: 'bullet',\n    })\n  );\n\n  bullets.push(bulletsGameObj);\n  game.scene.addChild(bulletsGameObj);\n}\n\n// 4. 设置子弹的射击动画\ngame.ticker.add((e: UpdateParams) => {\n  for (let bulletIndex = bullets.length - 1; bulletIndex >= 0; bulletIndex--) {\n    const moveDis = bulletSpeed * (Date.now() - lastMoveTime)/1000;\n    const position = bullets[bulletIndex].transform.position;\n    position.x += Math.cos(bullets[bulletIndex].transform.rotation) * moveDis;\n    position.y += Math.sin(bullets[bulletIndex].transform.rotation) * moveDis;\n  }\n});\n\n```\n\n> 实际上需要考虑子弹的边界，怎么停止，但这里先省略。\n\n### 碰撞检测\n\n\n每个游戏对象都可以看成是一个矩形，所以可以将这个问题转化为判断矩形重叠。\n\n对于矩形重叠就可以很轻松的用投影到坐标轴上进行降维处理，这个问题就变成判断区间重叠。\n\n也就是，当同时满足y轴上的投影重叠和x轴上的投影重叠，我们可以得到出这两个矩形有重叠。\n\n![](./矩形重叠1.jpg)\n![](./矩形重叠2.jpg)\n\n```js\ninterface IRect {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\nexport const isRectangleOverlap = (rec1: IRect, rec2: IRect) => {\n    const x_overlap = !(rec1.x + rec1.width <= rec2.x || rec2.x + rec2.width <= rec1.x);\n    const y_overlap = !(rec1.height + rec1.y <= rec2.y || rec2.y + rec2.height <= rec1.y);\n    return x_overlap && y_overlap;\n}\n```\n\n#### 朴素碰撞检测\n\n我们判断每一帧的子弹有没有击中目标，最简单的方法就是迭代所有子弹，然后让每个子弹和每个怪物进行矩阵重叠测试。**参考碰撞demo和Cat**\n\n\n```js\n\n// 迭代每一个子弹\nfor (let bulletIndex = bullets.length - 1; bulletIndex >= 0; bulletIndex--) {\n\n  const { bulletWidth, bulletHeight } = bullets[bulletIndex];\n  const position = (bullets[bulletIndex].content as GameObject).transform.position;\n\n  // 迭代每一个怪物\n  monsters.forEach((monsterData) => monsterData.monsterList.forEach((monster) => {\n\n    // 判断重叠\n    if (isRectangleOverlap({\n      x: position.x - bulletWidth * 0.5,\n      y: position.y - bulletHeight * 0.5,\n      width: bulletWidth,\n      height: bulletHeight\n    }, {\n      x: monster.obj.transform.position.x - monster.width * 0.5,\n      y: monster.obj.transform.position.y - monster.height * 0.5,\n      width: monster.width,\n      height: monster.height,\n    })) {\n      // 处理击中事件\n      hitCallback(bullets[bulletIndex], monster);\n    }\n  }));\n}\n\n```\n\n> 然后在这里遇到了性能问题，具体可以看 Cat，在子弹数和怪物数量达到一定程度的时候会出现卡顿。通过性能测试确认是碰撞逻辑的问题。\n\n#### 优化思路\n\n扫描线算法是在计算几何中常用的一种技巧，我们需要模拟一条线，从下到上去处理。如下图（计算矩形面积）。其关键点是矩阵边的离散化。\n\n\n![](./%E6%89%AB%E6%8F%8F%E7%BA%BF1.png)\n\n找到的一个动图，离散化简单来说就是只需要扫描下面停顿的地方就可以了，扫描过程中是一步步的，而不是连续的。\n![](./%E6%89%AB%E6%8F%8F%E7%BA%BF3.svg)\n\n然后，就可以转化为一个区间问题了，通常用线段树去解决，这里就不展开。\n\n![](./%E6%89%AB%E6%8F%8F%E7%BA%BF2.png)\n\n---\n\n上述的例子是求矩形面积的，在碰撞检测的中，我们应当对所有子弹和怪兽进行离散化处理，先构建待扫描的队列。\n\n##### 构建扫描队列\n```js\n  // 构建待扫描队列\n  const list = [];\n  bullets.forEach((item) => {\n    // 加入子弹的上边到队列\n    list.push({\n      y: item.y_1,\n      item,\n      type: TYPE_MAP.BULLET\n    });\n    // 加入子弹的下边到队列\n    list.push({\n      y: item.y_2,\n      item,\n      type: TYPE_MAP.BULLET\n    });\n  });\n\n  monsters.forEach((item) => {\n    list.push({\n      y: item.y_1,\n      item,\n      type: TYPE_MAP.MONSTER\n    });\n    list.push({\n      y: item.y_2,\n      item,\n      type: TYPE_MAP.MONSTER\n    });\n  });\n\n  // 排序\n  list.sort((a, b) => a.y - b.y);\n```\n\n##### 迭代队列的每个元素，并且分类处理\n\n对于每个元素，我们分为怪物和子弹两种类型。每种类型都包括上边和下边。\n当扫描到上边的时候，加入到待检测碰撞队列，扫描下边的时候退出队列。\n\n由此可得到四种情况：\n\n1. 子弹的上边。（指第一次扫到的边）\n2. 子弹的下边。\n3. 怪物的上边。\n4. 怪物的下边。\n\n![](./%E7%A2%B0%E6%92%9E%E4%BC%98%E5%8C%96.png)\n\n从图里可以看出，当怪物A的上边被迭代到的时候，子弹队列里里面有两个元素，分别为1和2，所以我们只需要让怪物A和子弹1与子弹2进行碰撞检测便可以了，相当于缩小了对比的范围。\n\n例如，黄色小花只需要和红色部分的怪兽进行碰撞检测就可以了。\n\n![](./%E7%A2%B0%E6%92%9E%E4%BC%98%E5%8C%962.png)\n\n\n###### 但是实际上，我们可以进一步优化一下\n\n根据实际情况，我们大可认为一个子弹或者一个怪物的高度不高于100个像素点，那就可以将上面的红色方块切割成若干个100像素点高的小方块，那样我们就可以进一步的缩小对比范围。\n\n![](./%E7%A2%B0%E6%92%9E%E4%BC%98%E5%8C%963.png)\n\n\n```js\n\n    // 扫到子弹，且子弹退出了\n    if (item.type === TYPE_MAP.BULLET && item.y === item.item.y_2) {\n      // 标记子弹已销毁\n      item.item.isDestory = true;\n    }\n    // 扫到子弹，且子弹是刚进入的\n    if (item.type === TYPE_MAP.BULLET && item.y === item.item.y_1) {\n\n      const { x_1, x_2 } = item.item;\n      const x_1_index = Math.floor(x_1/100);\n      const x_2_index = Math.floor(x_2/100);\n\n      // 收集未销毁的怪物\n      temp_array = []\n\n      for (temp_index = monsterList[x_1_index].length-1; temp_index >= 0 ; temp_index--) {\n\n        const monster = monsterList[x_1_index][temp_index];\n        // 跳过被销毁的怪物\n        if (monster.item.isDestory ) {\n          break;\n        }\n        temp_array.push(monster);\n\n        // 判断是否重叠\n        if (isRectangleOverlap(monster.item, item.item)) {\n          hitCallback(item.item, monster.item);\n          break;\n        }\n      }\n      // 重置一下\n      monsterList[x_1_index] = temp_array;\n\n\n      // 没有重叠，且跨越了两个区间\n      if (temp_index === -1 && x_1_index !== x_2_index) {\n        temp_array = []\n\n        for (temp_index = monsterList[x_2_index].length-1; temp_index >= 0 ; temp_index--) {\n\n          const monster = monsterList[x_2_index][temp_index];\n          // 跳过被销毁的怪物\n          if (monster.item.isDestory ) {\n            break;\n          }\n          // 没有销毁的\n          temp_array.push(monster);\n\n\n          // 判断是否重叠\n          if (isRectangleOverlap(monster.item, item.item)) {\n            hitCallback(item.item, monster.item);\n            break;\n          }\n        }\n        \n        // 把没有销毁的怪物加回去\n        monsterList[x_2_index] = temp_array;\n\n        // 没有重叠的，新子弹进去子弹队列\n        if (temp_index === -1) {\n          bulletList[x_2_index].push(item);\n        }\n      }\n      // 没有重叠的，新子弹进去子弹队列\n      if (temp_index === -1) {\n        bulletList[x_1_index].push(item);\n      }\n    }\n```\n\n扫描到怪物的情况与子弹类似，就省略代码部分啦。\n\n> 思路上与四叉树碰撞检测相似。\n\n#### 性能分析\n\n通过chrome的性能分析可以看出，Cat（碰撞检测优化）DEMO遇到的性能瓶颈是渲染元素过多导致的，而不是因为碰撞逻辑。\n\n### 分享完啦，感谢大家"}