{"fileName":"文件系统初探.md","dirList":["docs","Node","fs"],"name":"文件系统初探","createTime":1679414070444.374,"modifyTime":1679414071141.0596,"data":"\n# fs（文件系统）\n\n文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require('fs') 使用该模块。 所有的方法都有异步和同步的形式。\n\n> POSIX: Portable Operating System Interface of Unix.，可移植操作系统接口。\n> POSIX标准由IEEE（电气和电子工程师协会）发布，定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行软件而定义的一系列API标准的总称。\n>\n> 简单可以理解POSIX标准是为操作系统设计API时遵循的规范，一套规范的系统调用集。\n>\n\n## fs中的write和writeSync有什么区别？\n\n众所周知，在JavaScript的同步和异步是通过promise或async await来操作的，而fs是c++层面的。\n\n通过阅读源码发现了，其实本质上是通过一个 ==**binding**== 作为桥梁去使用C++进行o/i调用。\n\n### write\n\n```js\n// 例如在fs.write中\nfunction write(fd, buffer, offsetOrOptions, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n\n    if (typeof offset === 'object') {\n      ({\n        offset = 0,\n        length = buffer.byteLength - offset,\n        position = null,\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset, 'offset', 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    // 我们看到这里调用了binding.writeBuffer\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n}\n\nfunction writeSync(fd, buffer, offsetOrOptions, length, position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0,\n        length = buffer.byteLength - offset,\n        position = null,\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset, 'offset', 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    result = binding.writeBuffer(fd, buffer, offset, length, position,\n                                 undefined, ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer, 'buffer');\n    validateEncoding(buffer, length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd, buffer, offset, length,\n                                 undefined, ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n```\n\n我们可以看到write方法调用了binding.writeBuffer，writeSync中使用了binding.writeString，而这个writeButter和writeString实际上调用了[C++的WriteBuffer方法](https://github.com/nodejs/node/blob/main/src/node_file.cc#L2033)\n\n```C\n// 是这样设置了binding的方法的\nSetMethod(context, target, \"writeBuffer\", WriteBuffer);\nSetMethod(context, target, \"writeString\", WriteString);\n\n// Wrapper for write(2).\n//\n// bytesWritten = write(fd, buffer, offset, length, position, callback)\n// 0 fd        integer. file descriptor\n// 1 buffer    the data to write\n// 2 offset    where in the buffer to start from\n// 3 length    how much to write\n// 4 position  if integer, position to write at in the file.\n//             if null, write from the current position\nstatic void WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n  // 省略\n}\n```\n\n## fs操作文件\n\n### 查询\n\n\n\n"}