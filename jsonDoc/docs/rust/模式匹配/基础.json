{"fileName":"基础.md","dirList":["docs","rust","模式匹配"],"name":"基础","createTime":1686419291057.7085,"modifyTime":1686420102420.6758,"data":"## match\n\n先来看一个关于 match 的简单例子：\n\n```rust\nenum Direction {\n    East,\n    West,\n    North,\n    South,\n}\n\nfn main() {\n    let dire = Direction::South;\n    match dire {\n        Direction::East => println!(\"East\"),\n        Direction::North | Direction::South => {\n            println!(\"South or North\");\n        },\n        _ => println!(\"West\"),\n    };\n}\n```\n有以下几点值得注意：\n  - match 的匹配必须要穷举出所有可能，因此这里用 _ 来代表未列出的所有可能性\n  - match 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同\n  - X | Y，类似逻辑运算符 或，代表该分支可以匹配 X 也可以匹配 Y，只要满足一个即可\n\n> 其实 match 跟其他语言中的 switch 非常像，_ 类似于 switch 中的 default。\n\n### match与函数配合的例子\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny =>  {\n            println!(\"Lucky penny!\");\n            1\n        },\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n```\n\n这里通过函数`value_in_cents`匹配到的硬币，来返回美分数值（将`match`作为返回值）\n\n> 看起来这个`match`与三目表达式的用法也类似，也算是一个表达式\n\n### match来赋值\n\n既然它可以当成是表达式进行处理，那理所应当可以用来赋值啦。\n\n```rust\nenum IpAddr {\n   Ipv4,\n   Ipv6\n}\n\nfn main() {\n    let ip1 = IpAddr::Ipv6;\n    let ip_str = match ip1 {\n        IpAddr::Ipv4 => \"127.0.0.1\",\n        _ => \"::1\",\n    };\n\n    println!(\"{}\", ip_str);\n}\n```\n\n在这里`ip_str`的值是通过`match`模式匹配表达式来决定的。"}