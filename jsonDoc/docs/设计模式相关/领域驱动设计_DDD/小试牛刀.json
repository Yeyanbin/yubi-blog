{"fileName":"小试牛刀.md","dirList":["docs","设计模式相关","领域驱动设计_DDD"],"name":"小试牛刀","createTime":1679414070484.669,"modifyTime":1679414071894.364,"data":"\n### Composition Api\n\n组合式api作为Function-based API提案的产物，解决了**逻辑关注点**过于分散的问题。\n\n这是一个大型组件的示例，其中逻辑关注点按颜色进行分组。\n\n![](https://v3.cn.vuejs.org/images/options-api.png)\n\n这个示例展示了大型组件的逻辑是很容易碎片化的，这种碎片化使理解和维护变得困难。而Composition Api将同一个逻辑关注点的相关代码进行收集。\n\n> 引申：解决方案是通过一系列api去淘汰this和让响应式处理更加灵活，关于api部分并不是本文讨论的范围。\n\n#### 组合式的示例\n\n这里引用小商店的商品部分的`storeGoods`组件的部分内容来说明碎片化带来的问题。\n\n```js\n\n{\n  // 省略components和props\n  data() {\n    return {\n      // 选择模式\n      goodsTab: DEFAULT_GOODS_TAB,\n      goodsType: DEFAULT_GOODS_TYPE,\n\n      selectGoodsList: [], // 选择的商品列表\n    };\n  },\n  computed: {\n    getGoodsMode() {\n      // 'request' or 'static'\n    }\n  },\n  methods: {\n    updateStoreGoods() {\n      // 更新商品 调用了this.getIllegalRecord\n    },\n    batchBanGoods(show) {\n      // 自营商品下架\n    },\n    batchBanGoodsSubmit(close, form) {\n      // 自营商品批量下架\n      // 这里的逻辑是通过 this.selectGoodsList 一个个封禁商品，然后判断this.getGoodsMode的模式去判断处理方法\n    },\n    BanGoodsAmsSubmit(product, close) {\n      // ams商品下架请求\n    },\n\n    batchBanAmsGoodsSubmit() {\n      // ams商品批量下架\n    },\n\n    reBangoodsSubmit() {\n      // 自营商品解封\n    },\n    onReBanComGood() {\n      // 组件商品解封\n    },\n    getIllegalRecord(bizuin, goodsId) {\n      // 获取违规原因，\n    },\n    toComGoodInfo() {\n      // 查看组件商品详情\n    },\n    banGoodsSuccess(res, fromData) {\n      // 处罚商品成功 修改对应商品的状态，updateStoreGoods\n    }\n  }\n}\n\n```\n\n在小商店profile页，由于不断迭代的过程中，逻辑关注点越来越多，要梳理一个逻辑需要必须不断地“跳转”相关代码块，这就是碎片化逻辑在实际开发中带来的危害。\n\n我们应该怎么去使用组合化API去将其优化呢？因为这个例子的逻辑过于复杂，需要甚至有多个弹窗，有部分方法例如`updateStoreGoods,banGoodsSuccess,getIllegalRecord`会在多个逻辑中被调用，整个vue组件就是一个超级大的胶水层，各种逻辑缠绵在一起，只靠组合式api难以对胶水进行拆解。（实际上，组合式api的文档里就没有教我们这些。）\n\n我们可以尝试去用DDD去进行优化。\n\n## 重新设计storeGood组件\n"}