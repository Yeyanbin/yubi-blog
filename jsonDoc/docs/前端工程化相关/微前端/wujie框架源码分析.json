{"fileName":"wujie框架源码分析.md","dirList":["docs","前端工程化相关","微前端"],"name":"wujie框架源码分析","createTime":1679414070454.8774,"modifyTime":1679414071433.05,"data":"\n# wujie方案做了什么？\n\n> 主要是想了解一下iframe的优化\n\n在React和Vue都提供了组件库去封装使用。在这里以wujie-vue3起点，好好探究一下wujie方案做了什么。\n\n## wujie-vue3\n\n### 插件注册\n\n这里只是注册组件和设置属性而已\n```js\n// https://github.com/Tencent/wujie/blob/24a8a4cc9fe49a1be2c854acfddcbe752d7c3fe6/packages/wujie-vue3/index.js#L96\nWujieVue.setupApp = setupApp;\nWujieVue.preloadApp = preloadApp;\nWujieVue.bus = bus;\nWujieVue.destroyApp = destroyApp;\n\nWujieVue.install = function (app) {\n  app.component(\"WujieVue\", WujieVue);\n};\n```\n### 组件运行\n\n我们可以看到在组件的生命周期mounted的时候，执行了`wujie-core`的startApp方法。\n\n```js\n// https://github.com/Tencent/wujie/blob/24a8a4cc9fe49a1be2c854acfddcbe752d7c3fe6/packages/wujie-vue3/index.js#L36\nmounted() {\n  bus.$onAll(this.handleEmit);\n  // 这里执行了execStartApp\n  this.execStartApp();\n  this.$watch(\n    () => this.name + this.url,\n    () => this.execStartApp()\n  );\n},\n\n// 看起来这个部分就是关键了，\nexecStartApp() {\n  this.startAppQueue = this.startAppQueue.then(async () => {\n    try {\n      this.destroy = await startApp({\n        name: this.name,\n        url: this.url,\n        el: this.$refs.wujie,\n        alive: this.alive,\n        fetch: this.fetch,\n        props: this.props,\n        attrs: this.attrs,\n        replace: this.replace,\n        sync: this.sync,\n        prefix: this.prefix,\n        fiber: this.fiber,\n        degrade: this.degrade,\n        plugins: this.plugins,\n        beforeLoad: this.beforeLoad,\n        beforeMount: this.beforeMount,\n        afterMount: this.afterMount,\n        beforeUnmount: this.beforeUnmount,\n        afterUnmount: this.afterUnmount,\n        activated: this.activated,\n        deactivated: this.deactivated,\n        loadError: this.loadError,\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  });\n},\n\n```\n\n\n### wujie-core\n\n在阅读wujie-core的startApp方法之后，我们可以发现实际初始化创建了一个`WuJie`实例，其便是创建了一个沙箱。\n\n```js\n// https://github.com/Tencent/wujie/blob/91e6404b3122974c2a8ed643e740c68704e0bb07/packages/wujie-core/src/index.ts#L142\n\nexport async function startApp({\n  /* ...省略 */\n}: startOptions): Promise<Function | void> {\n  const sandbox = getSandboxById(name);\n  const lifecycles = {\n  /* ...省略 */\n  };\n  // 已经初始化过的应用，快速渲染\n  if (sandbox) {\n    sandbox.lifecycles = lifecycles;\n    const iframeWindow = sandbox.iframe.contentWindow;\n    if (sandbox.preload) {\n      await Promise.resolve(sandbox.preload);\n    }\n    if (alive) {\n      // 保活\n      await sandbox.active({ url, sync, prefix, el, props, alive, fetch, replace });\n      // 预加载但是没有执行的情况\n      if (!sandbox.execFlag) {\n        sandbox.lifecycles?.beforeLoad?.(sandbox.iframe.contentWindow);\n        const { getExternalScripts } = await importHTML(url, {\n          fetch: fetch || window.fetch,\n          plugins: sandbox.plugins,\n          loadError: sandbox.lifecycles.loadError,\n        });\n        await sandbox.start(getExternalScripts);\n      }\n      sandbox.lifecycles?.activated?.(sandbox.iframe.contentWindow);\n      return sandbox.destroy;\n    } else if (isFunction(iframeWindow.__WUJIE_MOUNT)) {\n      /**\n       * 子应用切换会触发webcomponent的disconnectedCallback调用sandbox.unmount进行实例销毁\n       * 此处是防止没有销毁webcomponent时调用startApp的情况，需要手动调用unmount\n       */\n      sandbox.unmount();\n      await sandbox.active({ url, sync, prefix, el, props, alive, fetch, replace });\n      // 有渲染函数\n      sandbox.lifecycles?.beforeMount?.(sandbox.iframe.contentWindow);\n      iframeWindow.__WUJIE_MOUNT();\n      sandbox.lifecycles?.afterMount?.(sandbox.iframe.contentWindow);\n      sandbox.mountFlag = true;\n      sandbox.rebuildStyleSheets();\n      return sandbox.destroy;\n    } else {\n      // 没有渲染函数\n      sandbox.destroy();\n    }\n  }\n\n  // 这里就是没有初始化的wujie应用初始化的情况\n  const newSandbox = new WuJie({ name, url, attrs, fiber, degrade, plugins, lifecycles });\n  newSandbox.lifecycles?.beforeLoad?.(newSandbox.iframe.contentWindow);\n  const { template, getExternalScripts, getExternalStyleSheets } = await importHTML(url, {\n    fetch: fetch || window.fetch,\n    plugins: newSandbox.plugins,\n    loadError: newSandbox.lifecycles.loadError,\n  });\n\n  const processedHtml = await processCssLoader(newSandbox, template, getExternalStyleSheets);\n  await newSandbox.active({ url, sync, prefix, template: processedHtml, el, props, alive, fetch, replace });\n  await newSandbox.start(getExternalScripts);\n  return newSandbox.destroy;\n}\n\n```\n\n\n### 沙箱的创建\n\n沙箱的代码注释友好得有点感人啊。\n\n我们先不管应用降级的与代理window的内容，这里只需要关注`iframeGenerator`方法，其创建了iframe。\n\n```js\n// https://github.com/Tencent/wujie/blob/91e6404b3122974c2a8ed643e740c68704e0bb07/packages/wujie-core/src/sandbox.ts#L421\n// Wujie的构造函数\n  /**\n   * @param id 子应用的id，唯一标识\n   * @param url 子应用的url，可以包含protocol、host、path、query、hash\n   */\n  constructor(options: {\n    name: string;\n    url: string;\n    attrs: { [key: string]: any };\n    degradeAttrs: { [key: string]: any };\n    fiber: boolean;\n    degrade;\n    plugins: Array<plugin>;\n    lifecycles: lifecycles;\n  }) {\n    // 传递inject给嵌套子应用\n    if (window.__POWERED_BY_WUJIE__) this.inject = window.__WUJIE.inject;\n    else {\n      this.inject = {\n        idToSandboxMap: idToSandboxCacheMap,\n        appEventObjMap,\n        mainHostPath: window.location.protocol + \"//\" + window.location.host,\n      };\n    }\n    const { name, url, attrs, fiber, degradeAttrs, degrade, lifecycles, plugins } = options;\n    this.id = name;\n    this.fiber = fiber;\n    this.degrade = degrade || !wujieSupport;\n    this.bus = new EventBus(this.id);\n    this.url = url;\n    this.degradeAttrs = degradeAttrs;\n    this.provide = { bus: this.bus };\n    this.styleSheetElements = [];\n    this.execQueue = [];\n    this.lifecycles = lifecycles;\n    this.plugins = getPlugins(plugins);\n\n    // 创建目标地址的解析\n    const { urlElement, appHostPath, appRoutePath } = appRouteParse(url);\n    const { mainHostPath } = this.inject;\n    // 创建iframe\n    this.iframe = iframeGenerator(this, attrs, mainHostPath, appHostPath, appRoutePath);\n\n    if (this.degrade) {\n      const { proxyDocument, proxyLocation } = localGenerator(this.iframe, urlElement, mainHostPath, appHostPath);\n      this.proxyDocument = proxyDocument;\n      this.proxyLocation = proxyLocation;\n    } else {\n      const { proxyWindow, proxyDocument, proxyLocation } = proxyGenerator(\n        this.iframe,\n        urlElement,\n        mainHostPath,\n        appHostPath\n      );\n      this.proxy = proxyWindow;\n      this.proxyDocument = proxyDocument;\n      this.proxyLocation = proxyLocation;\n    }\n    this.provide.location = this.proxyLocation;\n\n    addSandboxCacheWithWujie(this.id, this);\n  }\n```\n\n\n### iframeGenerator\n\n这里很神奇的创建了一个不可见(iframe)的iframe标签，且加入到主应用的body下。\n\n![](./wujie02.png)\n```js\n/**\n * js沙箱\n * 创建和主应用同源的iframe，路径携带了子路由的路由信息\n * iframe必须禁止加载html，防止进入主应用的路由逻辑\n */\nexport function iframeGenerator(\n  sandbox: WuJie,\n  attrs: { [key: string]: any },\n  mainHostPath: string,\n  appHostPath: string,\n  appRoutePath: string\n): HTMLIFrameElement {\n  const iframe = window.document.createElement(\"iframe\");\n  const attrsMerge = { src: mainHostPath, ...attrs, style: \"display: none\", name: sandbox.id, [WUJIE_DATA_FLAG]: \"\" };\n  setAttrsToElement(iframe, attrsMerge);\n  window.document.body.appendChild(iframe);\n\n  const iframeWindow = iframe.contentWindow;\n  // 变量需要提前注入，在入口函数通过变量防止死循环\n  patchIframeVariable(iframeWindow, sandbox, appHostPath);\n  stopIframeLoading(iframeWindow, mainHostPath, appHostPath, appRoutePath, sandbox);\n  return iframe;\n}\n\n```\n\n看到这里便可以大致明白了wujie的iframe优化思路：提前创建一个空白的不可见的iframe去加载资源。\n\n> 一些疑问\n> 1. 组件mounted的时候才加载资源，是否真的能达到“预加载”的效果呢？待解决\n> 2. 为什么实际展示的时候要用到ShadowRoot，而不是直接将这个不可视的iframe变可视呢？\n>   - 2问题的解答：shadowRoot为了解决html割裂的问题，而js运行在iframe，所以要把该iframe的Dom操作代理到shadowRoot上。\n> \n"}