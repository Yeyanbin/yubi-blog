{"fileName":"使用jest测试异步函数.md","dirList":["docs","JavaScirpt","jest"],"name":"使用jest测试异步函数","createTime":1679414070419.1443,"modifyTime":1679414070541.495,"data":"\n# 使用异步\n\n## 使用异步的四种方法\n\n1. done回调\n2. 返回promise\n3. 匹配器的.resolve和.reject方法\n4. async & await\n\n### done回调\n\n```js\n// done回调\ntest('the data is peanut butter', done => {\n  function callback(data) {\n    try {\n      expect(data).toBe('peanut butter');\n      done();\n    } catch (error) {\n      done(error);\n    }\n  }\n\n  fetchData(callback);\n});\n\n```\n若 done() 函数从未被调用，测试用例会正如你预期的那样执行失败（显示超时错误）。\n\n若 expect 执行失败，它会抛出一个错误，后面的 done() 不再执行。 若我们想知道测试用例为何失败，我们必须将 expect 放入 try 中，将 error 传递给 catch 中的 done函数。 否则，最后控制台将显示一个超时错误失败，不能显示我们在 expect(data) 中接收的值。\n\n> 注意： done() 不应与Promises混合，因为这会导致您测试中的内存泄漏。\n\n\n```js\n\n// 返回promise\ntest('the data is peanut butter', () => {\n  return fetchData().then(data => {\n    expect(data).toBe('peanut butter');\n  });\n});\n\ntest('the fetch fails with an error', () => {\n  expect.assertions(1);\n  return fetchData().catch(e => expect(e).toMatch('error'));\n});\n```\n\n```js\n\n// 匹配器的.resolve和.reject方法\ntest('the data is peanut butter', () => {\n  return expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', () => {\n  return expect(fetchData()).rejects.toMatch('error');\n});\n\n// async & await\ntest('the data is peanut butter', async () => {\n  const data = await fetchData();\n  expect(data).toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  expect.assertions(1);\n  try {\n    await fetchData();\n  } catch (e) {\n    expect(e).toMatch('error');\n  }\n});\n```\n\n你也可以将 async and await和 .resolves or .rejects一起使用。\n\n```js\ntest('the data is peanut butter', async () => {\n  await expect(fetchData()).resolves.toBe('peanut butter');\n});\n\ntest('the fetch fails with an error', async () => {\n  await expect(fetchData()).rejects.toMatch('error');\n});\n```"}