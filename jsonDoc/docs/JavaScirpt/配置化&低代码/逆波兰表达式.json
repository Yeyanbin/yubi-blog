{"fileName":"逆波兰表达式.md","dirList":["docs","JavaScirpt","配置化&低代码"],"name":"逆波兰表达式","createTime":1679414070443.2979,"modifyTime":1679414071144.7068,"data":"\n# 什么是逆波兰表达式\n\n逆波兰表达式又称后缀表达式，日常我们使用的运算公式叫中缀表达式。例如`1 + 1 = 2`， `x * y = z`。\n\n而逆波兰表达式把运算量写在前面,把算符写在后面，是一种没有括号，并严格遵循“从左到右”运算的后缀式表达方法。\n\n正常表达式|逆波兰表达式\n---|---\n1+2| 1, 2, +\na+b|a, b, +\n(1*2+3)*(3+4/2)|  1, 2, \\*, 3, +, 3, 4, 2, /, +, \\*\n(1+2)*(3+4) | 1, 2, +, 3, 4, +, \\*\n\n# 中缀表达式转换成逆波兰表达式\n\n## 双栈解法\n\n- elementStack —— 元素栈\n- operationStack —— 运算符栈\n\n`(1+2)*(3+4)`转换成`1, 2, +, 3, 4, +, *`的过程如下\n\nexpression|elementStack|operationStack| 操作\n---|---|---|---\n1+2)*(3+4)|[  ]|[ ( ] | 发现(，进operationStack\n+2)*(3+4)|[ 1 ]|[ ( ] | 发现1，进elementStack\n2)*(3+4)|[ 1 ]|[ (, + ] | 发现+，进operationStack\n)*(3+4)|[ 1, 2 ]|[ (, + ] | 发现2，进elementStack\n*(3+4)|[ 1, 2, +]|[ ] | 发现)，将operationStack的元素依次出栈，进elementStack，直到发现(\n(3+4)|[ 1, 2, +]|[ * ] | 发现*，进elementStack\n3+4)|[ 1, 2, +]|[ *, ( ] | 发现(，进operationStack\n+4)|[ 1, 2, +, 3]|[ *, (] | 发现3，进elementStack\n4)|[ 1, 2, +, 3]|[ *, (, +] | 发现+，进operationStack\n)|[ 1, 2, +, 3, 4]|[ *, (, +] | 发现4，进elementStack\n/ |[ 1, 2, +, 3, 4, +]|[ *] | 发现)，将operationStack的元素依次出栈，进elementStack，直到发现(\n/ |[ 1, 2, +, 3, 4, +, *]| [] | expresstion为空，将operationStack的元素依次出栈，进elementStack，（只会有一个）\n\n最后的`elementStack`就是逆波兰表达式\n\n## 逻辑拆分\n\n### 简单算式 1+2\n\n从左到右，是数字就加入到元素栈，是操作符就加入到运算符栈，迭代完expression后，运算符栈的元素依次出栈，进栈到操作符\n\nexpression|elementStack|operationStack\n---|---|---\n1+2|[ 1 ]|[ ]\n+2|[ 1 ]|[ + ]\n2|[ 1, 2 ]|[ + ]\n\\ | [1, 2, +]| []\n\n### 括号处理 3+(1+2)\n\nexpression|elementStack|operationStack\n---|---|---\n3*(1+2)|[ 1 ]|[ ]\n)|[3, 1, 2]|[ *, (, + ]\n\\ |[3, 1, 2]|[ *, (, + ]\n\noperationStack开始弹栈，依次进栈elementStack，直到发现 (\n\nexpression|elementStack|operationStack\n---|---|---\n\\ |[3, 1, 2, +]|[ * ]\n\n### 运算符的优先级 1/2+3\n\nexpression|elementStack|operationStack\n---|---|---\n1+2/3| [] |[]\n/3| [1, 2] | [ /]\n3| [1, 2] | [ /] `← +`\n\n`+`的优先级是低于`/`的，operationStack必须要保证优先级的有序性，要将比`+`优先级高的运算符依次出栈，进elementStack。\n\nexpression|elementStack|operationStack\n---|---|---\n3| [1, 2, /] | [ +]\n\\ | [1, 2, /, 3] | [ +]\n\\ | [1, 2, /, 3, +] |\n\n### 运算符的优先级 4*(1/2+3)\n\n只需要考虑括号内部的优先级\n\nexpression|elementStack|operationStack\n---|---|---\n3| [4, 1, 2] | [ *, (, /] `← +`\n3| [4, 1, 2, /] | [ *, (, +]\n\\ | [4, 1, 2, /, 3 +, *] |\n\n### 自定义运算符\n\n我们定义一种新的运算符为⊙，`a ⊙ b = c`，当a为b的质因数的时候，c为1，否则c为0。\n\n例如：`2 ⊙ 4 = 1; 3 ⊙ 4 = 0;`\n\n> Tips：质因数（素因数或质因子）在数论里是指能整除给定正整数的质数。\n\n而优先级的定义如下：\n\n优先级| 运算符\n---|---\n1| `+ -`\n2| `* /`\n3| `⊙`\n\n#### ⊙的例子\n\n##### 1+2*5⊙35\n\nexpression|elementStack|operationStack\n---|---|---\n1+2*5⊙35 | [] | []\n*5⊙35| [1, 2] | [+, ]\n⊙35| [1, 2, 5] | [+, *]\n\\ | [1, 2, 5, 35] | [+, *, ⊙]\n\\ | [1, 2, 5, 35, ⊙, *, +] | []\n\n逆波兰表达式：`[1, 2, 5, 35, ⊙, *, +]`\n\n##### (1+2*3)⊙35\n\nexpression|elementStack|operationStack\n---|---|---\n(1+2*3)⊙35 | [] | []\n*3)⊙35| [1, 2] | [(, +, ]\n)⊙35| [1, 2, 3] | [(, +, *]\n⊙35| [1, 2, 3, *, +] | []\n\\ | [1, 2, 3, *, +, 35, ⊙] | []\n\n逆波兰表达式：`[1, 2, 3, *, +, 35, ⊙]`\n\n##### 只需要确认好优先级，就可以很轻松在逆波兰表达式中引入运算符&，|，>, <, =, ^\n\n优先级| 运算符\n---|---\n0| `&, | > < =`\n1| `+ -`\n2| `* /`\n3| `^`\n\n## 在中缀表达式中使用变量\n\n在某些情况中，我们可能需要类似`{x}*2 + {y}`的表达式去满足一些业务需求。\n\n例如鼠标跟随+解决偏移，实现标签的居中拖拽：`offsetX = {mouseX}-{width}/2`,  `offsetY = {mouseY}-{height}/2`\n\n### 非基本数据类型的使用\n\n假设存在运算符 `$has`，可以用于判断一个圆中是否拥有另一个圆, `{circleA} $has {circleB}`\n\n```js\nconst state = {\n  circleA: {\n    x: 10,\n    y: 10,\n    r: 10\n  },\n  circleB: {\n    x: 5,\n    y: 5,\n    r: 2,\n  }\n}\n\nconst circleHasComputed = (circle1, circle2) => {\n  const circle1To2 = Math.sqrt(Math.pow(Math.abs(circle1.x - circle2.x), 2) + Math.pow(Math.abs(circle1.y - circle2.y), 2))\n  return circle1To2 + circle2.r <= circle1.r ? 1 : 0;\n};\n\n\n```\n\n### 引入状态\n\n```js\nconst state = {\n  width: 700,\n  height: 500,\n}\n```\n\n我们可以用`{width}`在表达式中使用状态\n\n`{width} > {height}`，则为`700 > 500 = 1`\n\n### 数组的运算例子\n\n假设存在运算符`join`，实现了类似数据库left join的效果，具体如下\n\n```js\nconst arrA = [\n  { id: 1, type: 0 },\n  { id: 2, type: 1 },\n  { id: 3, type: 1 },\n  { id: 4, type: 2 },\n  { id: 5, type: 2 },\n  { id: 6, type: 2 },\n];\n\nconst arrB = [\n  { id: 1, name: '张三' },\n  { id: 2, name: '赵四' },\n];\n\n'arrA $join arrB'\n/*\nnew Arr\n\n[\n  { id: 1, type: 0, name: ''张三 },\n  { id: 2, type: 1, name: '赵四' },\n  { id: 3, type: 1 },\n  { id: 4, type: 2 },\n  { id: 5, type: 2 },\n  { id: 6, type: 2 },\n]\n*/\n\n'arrB $join arrA'\n/* \nnew Arr\n[\n  { id: 1, type: 0, name: ''张三 },\n  { id: 2, type: 1, name: '赵四' },\n]\n*/\n```\n\n## 转换的代码实现\n\n```js\n/**\n * 中缀表达式转换逆波兰表达式\n * @param {string} expression \n */\nconst toReversePolishNotation = (expression) => {\n  const elementStack = [];\n  const operationStack = [];\n\n  for(let i = 0, len = expression.length ; i<len ; ++i) {\n    if (operaLevelMap[expression[i]]) {\n      // 是运算符\n      if (operationStack.length > 0) {\n        const topOpera = operationStack.pop();\n        if (operaLevelMap[expression[i]] > operaLevelMap[topOpera] || topOpera === '(') {\n          operationStack.push(topOpera, expression[i]);\n        } else {\n          elementStack.push(topOpera);\n          operationStack.push(expression[i]);\n        }\n      } else {\n        operationStack.push(expression[i]);\n      }\n    \n    } else if (expression[i] === '(') {\n      // 是 (\n      operationStack.push('(')\n    } else if (expression[i] === ')') {\n      // 是 )，往elementStack里塞运算符\n      let opera = '';\n      while((opera = operationStack.pop()) !== '(') {\n        elementStack.push(opera);\n      }\n    // 忽略\n    } else if (expression[i] === ' ') {\n      // continue;\n    } else {\n      // 是 element\n      let num = 0;\n      [num, i] = handleElement(expression, i);\n      elementStack.push(num);\n    }\n  }\n  return [...elementStack, ...operationStack];\n}\n\n\nconst handleElement = (expression, i) => {\n  if (expression[i] !== '{') {\n    return getNumber(expression, i);\n  } else {\n    return getState(expression, i);\n  }\n}\n\nconst getState = (expression, i) => {\n  i += 1;\n  const key = [];\n  while(expression[i] !== '}') {\n    key.push(expression[i]);\n    ++i;\n  }\n  return [state[key.join('')] || `$\\{${key.join('')}\\}`, i];\n}\n\nconst getNumber = (expression, i) => {\n  const nums = [];\n  while(Number.isInteger(+expression[i]) || expression[i] === '.') {\n    nums.push(expression[i]);\n    ++i;\n  }\n  return [+nums.join(''), i-1];\n};\n```\n\n# 逆波兰表达式的计算\n\n计算`1, 2, +, 3, 4, +, *`的流程如下：\n\nelementStack | numberStack| 操作\n---|---|---\n[ 2, +, 3, 4, +, * ]|[ 1 ]  | 发现1，进numberStack\n[ +, 3, 4, +, * ]|[ 1, 2 ]  | 发现2，进numberStack\n[ 3, 4, +, * ]|[ 3 ]        | 发现+，将numberStack的顶部两个元素出栈，执行1 + 2, 将结果3进numberStack\n[ 4, +, * ]|[ 3, 3 ]        | 发现3，进numberStack\n[ +, * ]|[ 3, 3, 4 ]        | 发现4，进numberStack\n[ * ]|[ 3, 7 ]              | 发现+，将numberStack的顶部两个元素出栈，执行3 + 4, 将结果7进numberStack\n/|[ 21 ]                    | 发现\\*，将numberStack的顶部两个元素出栈，执行3 * 7, 将结果21进numberStack\n\nnumberStack最后剩下的元素21便是运算结果。\n\n## 计算的代码实现\n\n```js\n/**\n * \n * @param {Array} reversePolishNotation 上面的elementStack\n */\nconst computeReversePolishNotation = (reversePolishNotation) => {\n  const numberStack = [];\n\n  reversePolishNotation.forEach((element) => {\n    if (typeof element === 'number') {\n      numberStack.push(element);\n    } else {\n      numberStack.push(handleCompute(numberStack.pop(), numberStack.pop(), element));\n    }\n    console.log(numberStack)\n  })\n  return numberStack.pop();\n}\n\nconst handleCompute = (num2, num1, sign) => {\n  return operaCompute[sign](num1, num2)\n};\n\n// 分发计算\nconst operaCompute = {\n  '=': (num1, num2) => {\n    return num1 === num2? 1: 0;\n  },\n  '>': (num1, num2) => {\n    return num1>num2? 1: 0;\n  },\n  '<': (num1, num2) => {\n    return num1<num2? 1: 0;\n  },\n  '&': (num1, num2) => {\n    return num1&num2? 1: 0;\n  },\n  '|': (num1, num2) => {\n    return num1|num2? 1: 0;\n  },\n  '+': (num1, num2) => {\n    return num1+num2;\n  },\n  '-': (num1, num2) => {\n    return num1 - num2;\n  },\n  '*': (num1, num2) => {\n    return num1*num2;\n  },\n  '/': (num1, num2) => {\n    return num1/num2;\n  },\n  '⊙': (num1, num2) => {\n    return !notPrimeMap[num1] && num2 % num1 === 0? 1: 0;\n  },\n  '^': (num1, num2) => {\n    return Math.pow(num1, num2);\n  }\n};\n```\n\n### 寻找变量的代码\n\n```js\nconst handleElement = (expression, i) => {\n  if (expression[i] !== '{') {\n    return getNumber(expression, i);\n  } else {\n    return getState(expression, i);\n  }\n}\n\nconst getState = (expression, i) => {\n  i += 1;\n  const key = [];\n  while(expression[i] !== '}') {\n    key.push(expression[i]);\n    ++i;\n  }\n  return [state[key.join('')] || `$\\{${key.join('')}\\}`, i];\n}\n```"}