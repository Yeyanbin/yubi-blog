{"fileName":"装饰器介绍.md","dirList":["docs","JavaScirpt","装饰器","decorator"],"name":"装饰器介绍","createTime":1679414070429.5642,"modifyTime":1679414070958.0823,"data":"\n# 装饰器\n\n随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持**标注或修改类及其成员。**\n\n> 虽然可以修改类及其成员，但是在学习中发现，修改类及其成员的行为是非常危险的\n\n## 装饰器是什么\n\n装饰器是一种特殊类型的声明，它可以被附加到类声明，方法，访问符，属性或参数上。\n\n### 类装饰器\n\n类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。\n\n- 下面通过一个动物园的例子来介绍一下类装饰器，**这里对类进行了修改，重载了构造函数**\n\n```ts\nconst zooArea = {};\nconst addAnimal = (key, value) => {\n  if (zooArea[key]) {\n    zooArea[key].push(value);\n  } else {\n    zooArea[key] = [value];\n  }\n};\nconst getArea = (key) => zooArea[key];\n\nconst Zoo = ({\n  family,\n  desc,\n}) => {\n  return (constructor: Function) => {\n    console.log('Zoo doing!')\n    return function (name: string) {\n      addAnimal(family, { desc, name });\n      return new (constructor as any)(name);\n    } as any\n  }\n};\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n@Zoo({\n  family: '猫科',\n  desc: '只是普通的小猫咪，偶尔抓只小鸟或老鼠'\n})\nclass Cat extends Animal{\n  constructor(name: string) {\n    super(name);\n  }\n}\n\n@Zoo({\n  family: '犬科',\n  desc: '这是一只可爱的小狗，但是大多数人来动物园都不是为了看它'\n})\nclass Dog extends Animal{\n  constructor(name: string) {\n    super(name);\n  }\n}\n\n@Zoo({\n  family: '猫科',\n  desc: '老虎是动物园里面最受小朋友欢迎的之一'\n})\nclass Tiger extends Animal{\n  constructor(name: string) {\n    super(name);\n  }\n}\n\nconst cat_1 = new Cat('小红');\nconst cat_2 = new Cat('小明');\nconst cat_3 = new Cat('小张');\nconst cat_4 = new Cat('小亮');\n\nconst dog_1 = new Dog('张三');\nconst dog_2 = new Dog('李四');\nconst dog_3 = new Dog('王五');\n\nconst tiger_1 = new Tiger('甲');\nconst tiger_2 = new Tiger('乙');\nconst tiger_3 = new Tiger('丙');\nconst tiger_4 = new Tiger('丁');\n\nconsole.log(zooArea)\n/*\n输出：\n{ '猫科':\n   [ { desc: '只是普通的小猫咪，偶尔抓只小鸟或老鼠', name: '小红' },\n     { desc: '只是普通的小猫咪，偶尔抓只小鸟或老鼠', name: '小明' },\n     { desc: '只是普通的小猫咪，偶尔抓只小鸟或老鼠', name: '小张' },\n     { desc: '只是普通的小猫咪，偶尔抓只小鸟或老鼠', name: '小亮' },\n     { desc: '老虎是动物园里面最受小朋友欢迎的之一', name: '甲' },\n     { desc: '老虎是动物园里面最受小朋友欢迎的之一', name: '乙' },\n     { desc: '老虎是动物园里面最受小朋友欢迎的之一', name: '丙' },\n     { desc: '老虎是动物园里面最受小朋友欢迎的之一', name: '丁' } ],\n  '犬科':\n   [ { desc: '这是一只可爱的小狗，但是大多数人来动物园都不是为了看它', name: '张三' },   \n     { desc: '这是一只可爱的小狗，但是大多数人来动物园都不是为了看它', name: '李四' },   \n     { desc: '这是一只可爱的小狗，但是大多数人来动物园都不是为了看它', name: '王五' } ] }\n*/\n```\n\n### 方法装饰器\n\n方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件( .d.ts)，重载或者任何外部上下文（比如declare的类）中。\n\n- 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 成员的属性描述符。\n\n\n#### nestJs中的Get装饰器\n\n在nestjs中，我们经常接触到装饰器，这里解析一下Get装饰器做了什么。\n\n```ts\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller('cats')\nexport class CatsController {\n  @Get()\n  findAll(): string {\n    return 'This action returns all cats';\n  }\n}\n```\n\n- 在文档中是这么介绍上述代码的作用的。\n\n![](./nestjs_cat.png)\n\n大致意思是：`findAll`方法上面的HTTP方法装饰器会为HTTP请求的创建一个特殊处理：为特定请求`/cats`的路径映射到这个`findAll`方法上。这个路径是由于类构造器`@Controller`为这个类声明了一个前缀`cats`，而方法装饰器`Get`则没有添加任何路径信息，所以是`/cats`。\n\n### NestJS中方法装饰器Get源码梳理\n\n```ts\nexport const Get = createMappingDecorator(RequestMethod.GET);\n\nexport const PATH_METADATA = 'path';\nexport const METHOD_METADATA = 'method';\n\nconst createMappingDecorator =\n  (method: RequestMethod) =>\n  (path?: string | string[]): MethodDecorator => {\n    return RequestMapping({\n      [PATH_METADATA]: path,\n      [METHOD_METADATA]: method,\n    });\n  };\n\n/**\n * 这里是一个工厂函数，获取实际的HTTP装饰器\n */\nexport const RequestMapping = (\n  metadata: RequestMappingMetadata = defaultMetadata,\n): MethodDecorator => {\n  const pathMetadata = metadata[PATH_METADATA];\n  const path = pathMetadata && pathMetadata.length ? pathMetadata : '/'; // 从这里可以看到当path不存在的时候，默认是 '/'\n  const requestMethod = metadata[METHOD_METADATA] || RequestMethod.GET;\n\n  return (\n    target: object,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<any>,\n  ) => {\n    Reflect.defineMetadata(PATH_METADATA, path, descriptor.value);\n    Reflect.defineMetadata(METHOD_METADATA, requestMethod, descriptor.value);\n    return descriptor;\n  };\n};\n```\n\n---\n\n### 属性装饰器\n\n- 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n\n#### mock-decorator\n\n> https://github.com/Yeyanbin/mock-decorator 代码库在这里\n\nmock-decorator是基于属性装饰器和fakerjs来做的一个mock工具。\n\n我们可以用他来基于贫血模型创建一些模拟数据。\n\n> 贫血模型可以先简单理解为只有属性的类。（或者说只包含数据，不包含业务逻辑）\n\n```ts\nclass Date {\n  @NumberMock({ max: 2020, min: 2010, isInt: true })\n  year: number;\n\n  @NumberMock({ max: 13, min: 1, isInt: true })\n  month: number;\n}\n\nclass Skill {\n  @EnumMock(['卖萌', '捕猎', '跑酷', '抓老鼠'])\n  name: string;\n\n  @NumberMock({\n    max: 100\n  })\n  level: number;\n}\n\nclass Cat {\n  @Name.lastName('male')\n  name: string;\n\n  @ObjectMock(Date)\n  brithday: Date;\n\n  @ArrayMock({ max: 4 })\n  @Name.findName()\n  firendsName: string[]\n\n  @ArrayMock({ min: 1, max: 3 })\n  @ObjectMock(Skill)\n  skills: Skill[]\n}\n\nconsole.log(MockDataStore.instance.targetMap);\n\nconst cat_1 = handleMockBehavior(Cat);\nconst cat_2 = handleMockBehavior(Cat);\nconst cat_3 = handleMockBehavior(Cat);\n\nconsole.log('cat_1', cat_1);\nconsole.log('cat_2', cat_2);\nconsole.log('cat_3', cat_3);\n/*\n生成随机数据的输出：\ncat_1 { name: 'Roberts',\n  brithday: { year: 2017, month: 12 },\n  firendsName: [ 'Sean Price' ],\n  skills:\n   [ { name: '卖萌', level: 6.7813479251336295 },\n     { name: '捕猎', level: 95.58251369601594 } ] }\ncat_2 { name: 'Olson',\n  brithday: { year: 2013, month: 3 },\n  firendsName: [ 'Ms. Pam Hodkiewicz', 'Leslie Bednar' ],\n  skills:\n   [ { name: '捕猎', level: 74.36836676938398 },\n     { name: '捕猎', level: 22.77025925417544 },\n     { name: '跑酷', level: 35.21808489069889 } ] }\ncat_3 { name: 'Conn',\n  brithday: { year: 2012, month: 6 },\n  firendsName: [ 'Beatrice Koss' ],\n  skills:\n   [ { name: '卖萌', level: 44.026811694055844 },\n     { name: '抓老鼠', level: 11.329242733894706 },\n     { name: '跑酷', level: 99.4451728462999 } ] }\n*/\n\n```\n\n#### 基本设计\n\n- mock-decorator 分为三个模块\n\n1. decorator 装饰器\n2. MockDataStore mock数据存储器\n3. behavior 行为处理\n\n可以理解为：先用装饰器往MockDataStore中输入Mock行为数据，然后执行`handleMockBehavior`方法，处理MockDataStore中的Mock行为数据。\n\n##### NumberMock的逻辑梳理\n\n属性装饰器NumberMock，往MockDataStore注入Mock行为数据\n\n```ts\nclass Date {\n  @NumberMock({ max: 2020, min: 2010, isInt: true })\n  year: number;\n\n  @NumberMock({ max: 13, min: 1, isInt: true })\n  month: number;\n}\n\n\n/**\n * 随机数范围区间为： [min, max]，isInt代表是否取整。\n */\nexport const NumberMock = (options: { max?: number, min?: number, isInt?: boolean }) => {\n  const max = options.max ?? 100;\n  const min = options.min ?? 0;\n  const isInt = options.isInt ?? false;\n\n  return useMockBehavior({\n    [isNumberKey]: {\n      max,\n      min,\n      isInt,\n    }\n  })\n}\n\nexport const useMockBehavior = (params) => {\n\n  // 属性装饰器函数\n  return (target: any, propertyKey: string) => {\n\n    // 注入Mock行为数据\n    Object.keys(params).forEach((paramKey) => {\n      MockDataStore.instance.addMockData(target.constructor, propertyKey, paramKey, params[paramKey]);\n    })\n  };\n};\n\n```\n\n处理属性装饰器NumberMock\n\n```ts\nexport const handleMockBehavior = (target: Function) => {\n  \n  // 获取类构造函数为key的Mock数据 \n  const targetData = MockDataStore.instance.getMockData(target);\n\n  // 类的实例\n  const targetInstance = {};\n\n  // 该类没有Mock数据\n  if (!targetData) return\n\n  // 分别处理各个参数\n  Object.keys(targetData).forEach((key) => {\n    \n    // 如果这个参数有Mock行为数据 \n    if (targetData[key]) {\n      \n      // 判断是不是数组\n      const length = handleArrayBehavior(targetData[key]);\n      if (!!length) {\n        // 是数组\n        const result = [];\n        for(let i = 0; i<length ;++i) {\n          // 处理值数据\n          result.push(handleValueBehaviors(targetData[key]));\n        }\n        targetInstance[key] = result;\n      } else {\n        targetInstance[key] = handleValueBehaviors(targetData[key]);\n      }\n    }\n  });\n\n  return targetInstance;\n}\n\n// 优先级，Object > Number > faker > Enum\nconst handleValueBehaviors = (data) => {\n  let result;\n  result = handleObjectBehavior(data);\n  result = result ?? handleNumberBehavior(data); \n  result = result ?? handleFakeBehavior(data);\n  result = result ?? handleEnumBehavior(data);\n\n  return result;\n}\n\n// number\nconst handleNumberBehavior = (data) => {\n  let numberBehavior\n  if (numberBehavior = data[typeKeys.isNumberKey]) {\n    const { max, min, isInt } = numberBehavior;\n    \n    // 获取随机数据\n    const result = Math.random() * (max - min) + min;\n\n    // 如果是整数就取整\n    return isInt ? Math.floor(result) : result;\n  }\n  return\n}\n\n```\n\n### 参数装饰器\n\n参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。\n\n- 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：\n\n1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n2. 成员的名字。\n3. 参数在函数参数列表中的索引。\n\n> 注意:\n>\n> 1. 参数装饰器只能用来监视一个方法的参数是否被传入。\n> 2. 参数装饰器的返回值会被忽略。\n>\n\n例如可以用方法装饰器和参数装饰器，设计一个**运行时**的参数校验。\n\n```ts\nclass Greeter {\n    greeting: string;\n\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @validate\n    greet(@required name: string) {\n        return \"Hello \" + name + \", \" + this.greeting;\n    }\n}\n\n\nimport \"reflect-metadata\";\n\nconst requiredMetadataKey = Symbol(\"required\");\n\n// 参数构造器 \nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n    existingRequiredParameters.push(parameterIndex);\n\n    // 注入校验数据\n    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\n// 方法构造器\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n\n    // 原来的方法，就是上面的greet方法\n    let method = descriptor.value;\n\n    // 这里重载了函数\n    descriptor.value = function () {\n        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n        if (requiredParameters) {\n            for (let parameterIndex of requiredParameters) {\n                if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n                    throw new Error(\"Missing required argument.\");\n                }\n            }\n        }\n\n        // 调用回原来的方法\n        return method.apply(this, arguments);\n    }\n}\n```\n\n# 基于装饰器工具\n\n## class-validator\n\nhttps://github.com/typestack/class-validator\n\n使用基于装饰器和非装饰器的验证，基于validator.js执行验证。适用于浏览器和node环境。\n\n### 官方例子\n\n```ts\nimport {\n  validate,\n  validateOrReject,\n  Contains,\n  IsInt,\n  Length,\n  IsEmail,\n  IsFQDN,\n  IsDate,\n  Min,\n  Max,\n} from 'class-validator';\n\nexport class Post {\n  @Length(10, 20)\n  title: string;\n\n  @Contains('hello')\n  text: string;\n\n  @IsInt()\n  @Min(0)\n  @Max(10)\n  rating: number;\n\n  @IsEmail()\n  email: string;\n\n  @IsFQDN()\n  site: string;\n\n  @IsDate()\n  createDate: Date;\n}\n\nlet post = new Post();\npost.title = 'Hello'; // should not pass\npost.text = 'this is a great post about hell world'; // should not pass\npost.rating = 11; // should not pass\npost.email = 'google.com'; // should not pass\npost.site = 'googlecom'; // should not pass\n\nvalidate(post).then(errors => {\n  // errors is an array of validation errors\n  if (errors.length > 0) {\n    console.log('validation failed. errors: ', errors);\n  } else {\n    console.log('validation succeed');\n  }\n});\n\nvalidateOrReject(post).catch(errors => {\n  console.log('Promise rejected (validation failed). Errors: ', errors);\n});\n// or\nasync function validateOrRejectExample(input) {\n  try {\n    await validateOrReject(input);\n  } catch (errors) {\n    console.log('Caught promise rejection (validation failed). Errors: ', errors);\n  }\n}\n```\n\n## class-transformer\n\nClass-transformer用于类对象和普通对象之间转换，还提供了序列号和反序列化功能。\n\n### 官方示例\n\n我们有一个json文件 `users.json`和`user`类，则可以将其转换为类user的实例对象。\n\n```json\n[\n  {\n    \"id\": 1,\n    \"firstName\": \"Johny\",\n    \"lastName\": \"Cage\",\n    \"age\": 27\n  },\n  {\n    \"id\": 2,\n    \"firstName\": \"Ismoil\",\n    \"lastName\": \"Somoni\",\n    \"age\": 50\n  },\n  {\n    \"id\": 3,\n    \"firstName\": \"Luke\",\n    \"lastName\": \"Dacascos\",\n    \"age\": 12\n  }\n]\n```\n\n```ts\nexport class User {\n  id: number;\n  firstName: string;\n  lastName: string;\n  age: number;\n\n  getName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n\n  isAdult() {\n    return this.age > 36 && this.age < 60;\n  }\n}\n\nfetch('users.json').then((users: Object[]) => {\n  const realUsers = plainToClass(User, users);\n  // now each user in realUsers is an instance of User class\n});\n```\n\n# 其他注意事项\n\n## 装饰器的顺序\n\n- 类中不同声明上的装饰器将按以下规定的顺序应用\n\n1. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。\n2. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。\n3. 参数装饰器应用到构造函数。\n4. 类装饰器应用到类。\n\n- 当多个装饰器应用在一个声明上时会进行如下步骤的操作：\n\n1. 由上至下依次对装饰器表达式求值。\n2. 求值的结果会被当作函数，由下至上依次调用。\n\n## 最简单的装饰器\n\n> 无论怎么封装，装饰器本质上是Function\n\n```ts\n\n// 类装饰器\nfunction ClassDecorator(constructor: Function) {\n  console.log('类装饰器 done');\n}\n\n// 方法装饰器\nfunction FunctionDecorator(target, propertyKey: string, descriptor: PropertyDescriptor) {\n  console.log('方法装饰器 done');\n\n}\n\n// 属性装饰器\nfunction PropertDecorator(target: any, propertyKey: string) {\n  console.log('属性装饰器 done');\n\n}\n\n// 参数装饰器\nfunction ParamsDecorator(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  console.log('参数装饰器 done');\n\n}\n\n@ClassDecorator\nclass Demo {\n  @PropertDecorator\n  Propert: any;\n\n  @FunctionDecorator\n  func(@ParamsDecorator paramA) {}\n}\n\n/*\n执行顺序：\n\n属性装饰器 done\n参数装饰器 done\n方法装饰器 done\n类装饰器 done\n*/\n```\n"}