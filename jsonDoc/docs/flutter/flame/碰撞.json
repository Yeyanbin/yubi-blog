{"fileName":"碰撞.md","dirList":["docs","flutter","flame"],"name":"碰撞","createTime":1711040776071.9412,"modifyTime":1711557896890.2903,"data":"\n# CollisionComponent\n\nCollisionCallbacks 是一个用于处理碰撞事件的特性，它允许你在碰撞开始、碰撞持续和碰撞结束时执行自定义的逻辑。\n\n```dart\n// 以下是一个例子\nclass Bird extends SpriteGroupComponent<BirdMovement>\n    with HasGameRef<FlappyBirdGame>, CollisionCallbacks {\n  Bird();\n\n  int score = 0;\n\n  // 在这个 onLoad() 方法中，小鸟的初始化逻辑被执行。\n  @override\n  Future<void> onLoad() async {\n\n    // 这里加载了brid在三种不同状态的资源\n    final birdMidFlap = await gameRef.loadSprite(Assets.birdMidFlap); \n    final birdUpFlap = await gameRef.loadSprite(Assets.birdUpFlap);\n    final birdDownFlap = await gameRef.loadSprite(Assets.birdDownFlap);\n    \n    // bird的初始状态\n    size = Vector2(50, 40);\n    position = Vector2(50, gameRef.size.y / 2 - size.y / 2);\n    current = BirdMovement.middle;\n    sprites = {\n      BirdMovement.middle: birdMidFlap,\n      BirdMovement.up: birdUpFlap,\n      BirdMovement.down: birdDownFlap,\n    };\n\n    // 这行代码添加了一个圆形碰撞体组件，用于检测小鸟与其他碰撞体的碰撞。默认情况下，CircleHitbox() 的半径大小是根据其所属的组件的尺寸自动计算的。\n    add(CircleHitbox());\n  }\n\n  // CollisionCallbacks中的回调\n  @override\n  void onCollisionStart(\n    Set<Vector2> intersectionPoints,\n    PositionComponent other,\n  ) {\n    super.onCollisionStart(intersectionPoints, other);\n\n    gameOver();\n  }\n\n  // 。。。。。。省略若干方法\n}\n\n```\n\n## 回调方法\n\n可以在你的类中实现 CollisionCallbacks 提供的碰撞回调方法。这些方法包括：\n\n```dart\n//当两个碰撞体开始碰撞时调用。\n- void onCollisionStart(Set<Vector2> intersectionPoints, PositionComponent other): \n// 当两个碰撞体持续碰撞时调用。\n- void onCollisionUpdate(Set<Vector2> intersectionPoints, PositionComponent other):\n// 当两个碰撞体结束碰撞时调用。\n- void onCollisionEnd(PositionComponent other): \n```\n\n\n# Hitbox\n\n待补充\n\n# 碰撞中的数据交互\n\n这里通过一个简单的血量计算例子来示范一下\n\n碰撞的另一个组件具有 damage 属性表示伤害，并且你需要根据这个属性来计算血量（HP），我们可以在onCollisionStart碰撞回调中判断是否具有damage属性。\n\n```dart\nclass MyComponent extends PositionComponent with CollisionCallbacks {\n  int hp = 100; // 血量属性\n\n  @override\n  void onCollisionStart(Set<Vector2> intersectionPoints, PositionComponent other) {\n    super.onCollisionStart(intersectionPoints, other);\n    \n    // 检查另一个组件是否具有 damage 属性\n    if (other is HasDamage) {\n      // 获取另一个组件的 damage 属性，并根据它来计算血量\n      int damage = (other as HasDamage).damage;\n      hp -= damage;\n      \n      // 根据游戏逻辑处理血量更新后的情况\n      if (hp <= 0) {\n        // 如果血量小于等于 0，执行死亡逻辑\n        die();\n      } else {\n        // 如果血量大于 0，执行受伤逻辑\n        takeDamage();\n      }\n    }\n  }\n\n  void die() {\n    // 死亡逻辑\n  }\n\n  void takeDamage() {\n    // 受伤逻辑\n  }\n}\n\n// 定义一个具有 damage 属性的接口\nabstract class HasDamage {\n  int damage;\n}\n\n```"}