{"fileName":"Flutter.md","dirList":["docs","flutter"],"name":"Flutter","createTime":1710167035480.8254,"modifyTime":1710222111468.6206,"data":"\n# Flutter是什么\nFlutter 是由 Google 开发的跨平台移动应用开发框架，可以用来快速构建高性能，跨平台的应用。\n\n## Flutter的自绘引擎\n\n首先我们要从跨平台开发方案的三个时代说起，根据实现方式的不同，业内常见的观点是将主流的跨平台方案划分为三个时代：Web 容器时代，泛 Web 容器时代与自绘引擎时代。\n\n**Web 容器时代**：基于 Web 相关技术通过浏览器组件来实现界面及功能，典型的框架包括 Cordova(PhoneGap)、Ionic 和微信小程序。主要采用的是原生应用内嵌浏览器控件 WebView 的方式进行 HTML5 页面渲染。由于采用了 Web 开发技术，社区和资源非常丰富，开发效率也很高。但是，一个完整 HTML5 页面的展示要经历浏览器控件的加载、解析和渲染三大过程，性能消耗要比原生开发增加不少。\n**泛 Web 容器时代**：采用类 Web 标准进行开发，但在运行时把绘制和渲染交由原生系统接管的技术，代表框架有 React Native、Weex 和快应用。在泛 Web 容器时代，我们仍然采用前端友好的 JavaScript 进行开发，整体加载、渲染机制大大简化，并且由原生接管绘制，即将原生系统作为渲染的后端，为依托于 JavaScript 虚拟机的 JavaScript 代码提供所需要的 UI 控件的实体。我们MP项目里也有通过node-gyp调用其他语言的库，就是类似的实现。\n**自绘引擎时代**：Flutter 开辟了一种全新的思路，即从头到尾重写一套跨平台的 UI 框架，包括渲染逻辑，甚至是开发语言。渲染引擎依靠跨平台的 Skia 图形库来实现，Skia 引擎会将使用 Dart 构建的抽象的视图结构数据加工成 GPU 数据，交由 OpenGL 最终提供给 GPU 渲染，至此完成渲染闭环，因此可以在最大程度上保证一款应用在不同平台、不同设备上的体验一致性。\n\n> 下面让我们尝试开始学习Flutter\n\n# Widgets\n\n> 作为前端开发，我们可以从Widgets开始学习，这个就是我们日常接触到的组件component\n\nFlutter 中的 Widgets（小部件） 是构建用户界面的基本构建块。\n\n>它是从 React 中汲取灵感的现代框架构建的。核心思想是用Widgets构建 UI。Widgets描述了它们的视图在当前配置和状态下应该是什么样子的，可以包含布局、样式、交互等信息，并且可以嵌套和组合以构建复杂的用户界面。当Widgets的状态发生变化时，Widgets会重新构建其描述，框架会将其与之前的描述进行比较，以确定底层渲染树中从一个状态过渡到下一个状态所需的最小变化。\n\nWidgets 通过布局组合形成一种层次结构关系。我们通常把这个Widget结构称为 **Widget Tree**。\n\n```dart\nconst Center(\n  child:\n    Text('Hello, world!',\n      key: Key('title'),\n      textDirection: TextDirection.ltr,\n    ),\n)\n```\n\n这种树形结构就是Widget Tree，我们可以管他叫组件树。\n\n这是一个非常重要的概念，与之相对的还有Element Tree（元素树）\n\n**Widget Tree（组件树）**：Widget Tree 描述了用户界面的布局和结构，每个 Widget 负责渲染用户界面的一部分。Widget Tree 是静态的，它是开发者在代码中创建和组合的，决定了界面的外观和行为。\n\n**Element Tree（元素树）**： Element Tree 是 Widget Tree 的运行时表示，它是由框架创建和管理的。当应用程序运行时，Flutter 框架会根据 Widget Tree 创建对应的 Element Tree，它包含了每个 Widget 对应的 Element 对象。Element 是 Flutter 中用于管理 Widget 生命周期和状态的基本单元，它负责将 Widget 转换为渲染树的节点，并负责处理 Widget 的更新和重建。Element Tree 是动态的，它随着应用程序的运行状态而变化，根据用户交互和应用程序状态的变化而更新。可以类比为Web环境中的真实DOM。\n\n<!-- 演示一下添加新的菜单 -->\n\n## 小试牛刀\n\n让我们通过一个简单的菜单组件baseMenu来了解一下怎么写一个widgets\n\n```dart\nimport 'package:flutter/material.dart'; // 导入material组件库库\nimport '../types/type_menu.dart'; // 导入菜单类型\n\n//声明一个ClickableMenuList组件，同时继承StatelessWidget\nclass ClickableMenuList extends StatelessWidget {\n  final List<MenuItem> items;\n\n  // 构造函数也是需要的，这里的key和items都是没有默认值且必须\n  const ClickableMenuList({\n    required Key key,\n    required this.items,\n  }) : super(key: key);\n\n\n  // 这里返回我们的widgets tree\n  @override\n  Widget build(BuildContext context) { // context是上下文\n    return ListView.builder( // material组件库带的列表组件\n      itemCount: items.length, // 菜单个数\n      itemBuilder: (context, index) { // 渲染菜单的子Widget Tree\n        return Column( // 布局组件\n          children: [\n            ListTile( // 布局组件\n              title: Text(items[index].content), // 菜单名称\n              onTap: () { // 点击方法回调\n                items[index].onItemClick(items[index]);\n              },\n            )\n          ]\n        );\n      },\n    );\n  }\n}\n```\n\n### StatelessWidget是什么？\n\n> 这个问题一开始我也挺疑惑的\n\nStatelessWidget 是 Flutter 中的一个基础类，用于创建无状态的（静态的）UI 组件。StatelessWidget 是不可变的，它的外观和行为在整个生命周期内保持不变，不会受到外部数据的影响。\n\n与之相对的还有StatefulWidget，其是用于创造有状态的组件，它可以在运行时根据应用程序的状态进行更新。\n\n```dart\n// 带有状态的组件\nclass ClickableMenuList extends StatefulWidget {\n  final List<MenuItem> items;\n\n  const ClickableMenuList({\n    required Key key,\n    required this.items,\n  }) : super(key: key);\n\n  @override\n  _ClickableMenuListState createState() => _ClickableMenuListState();\n}\n\nclass _ClickableMenuListState extends State<ClickableMenuList> {\n  List<bool>? isSubMenuOpen; // 开关状态数组\n\n  @override\n  Widget build(BuildContext context) {\n    // dart的语法糖，为空则初始化\n    isSubMenuOpen ??= List<bool>.filled(widget.items.length, false);\n    \n    print('List ${widget.items.map((e) => e.child)}');\n    return ListView.builder( // 列表\n      itemCount: widget.items.length,\n      itemBuilder: (context, index) {\n        return Column(\n          children: [\n            ListTile(\n              title: Text(widget.items[index].content),\n              onTap: () {\n                widget.items[index].onItemClick(widget.items[index]);\n              },\n              // 展开子菜单的按钮icon\n              trailing: widget.items[index].child.isNotEmpty ? IconButton(\n                icon: Icon(isSubMenuOpen![index] ? Icons.expand_less : Icons.expand_more),\n                onPressed: () {\n                  setState(() {\n                    isSubMenuOpen![index] = !isSubMenuOpen![index];\n                  });\n                },\n              ) : null,\n            ),\n            if (isSubMenuOpen![index])\n                ListView.builder( // 子列表\n                  itemCount: widget.items[index].child.length,\n                  itemBuilder: (subContext, subIndex) {\n                    // print('test1234 ${subIndex}');\n                    return Column(\n                      children: [\n                        ListTile(\n                          title: Text(subContext.[subIndex].content),\n                          onTap: () => {\n                            widget.items[index].child[subIndex].onItemClick(widget.items[index].child[subIndex])\n                          },\n                        )]\n                    );\n                  },\n              )\n          ]);\n      },\n    );\n  }\n}\n```\n\n这个组件本质上是相对简单的，但可读性和可维护性差的问题已经初见端倪。\n\n## Widgets嵌套地狱问题\n\n> 对比Vue的模版，React的Jsx，fultter的widget Tree中更容易遇到嵌套地狱的问题\n\n嵌套地狱通常指的是在一个组件中嵌套了过多的子组件，导致代码结构混乱、难以维护的情况。要处理这种情况，可以尝试**拆分组件**，减少Widget Tree的层级，保持组件设计的简洁。\n\n```dart\nclass ClickableMenuList extends StatefulWidget {\n  final List<MenuItem> items;\n\n  const ClickableMenuList({\n    required Key key,\n    required this.items,\n  }) : super(key: key);\n\n  @override\n  _ClickableMenuListState createState() => _ClickableMenuListState();\n}\n\nclass _ClickableMenuListState extends State<ClickableMenuList> {\n  List<bool>? isSubMenuOpen;\n\n  @override\n  Widget build(BuildContext context) {\n    // dart的语法糖，为空则初始化\n    isSubMenuOpen ??= List<bool>.filled(widget.items.length, false);\n    \n    print('List ${widget.items.map((e) => e.child)}');\n    return ListView.builder(\n      itemCount: widget.items.length,\n      itemBuilder: (context, index) {\n        MenuItem menuItem = widget.items[index];\n        return ExpansionTile( // 可拓展的组件\n          title: Text(menuItem.content),\n          children: _buildChildren(menuItem.child),\n          onExpansionChanged: (expanded) {\n            // 处理展开/折叠事件\n          },\n        );\n      }\n    );\n  }\n\n  List<Widget> _buildChildren(List<MenuItem>? children) {\n    if (children == null) {\n      return [];\n    }\n    return children.map((menuItem) {\n      return ListTile(\n        title: Text(menuItem.content),\n        onTap: () {\n          menuItem.onItemClick(menuItem);\n        },\n      );\n    }).toList();\n  }\n}\n\n```\n\n## Widgets组件\n\n像上面的ExpansionTile就是来自于material.dart库的。\n\nmaterial.dart 是 Flutter 提供的一个核心库，其中包含了实现 Material Design 规范的各种 UI 组件和工具。Material Design 是 Google 设计的一种视觉风格，旨在为移动设备和 Web 应用程序提供一致、美观的用户界面设计。\n\n相当于UI组件库，文档：https://api.flutter-io.cn/flutter/material/ExpansionTile-class.html\n\n# 总结\n\n我们掌握了上面的知识点之后，就可以愉快的入门flutter啦。\n\n> 虽然后面还有各种各样的坑，例如dart的类型，API方法，语法糖。Element tree性能问题呢。UI布局的多端兼容问题。数据管理问题。各种各样的核心库。但这些都是可以在实际开发中查阅文档。"}